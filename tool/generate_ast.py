import typing as t
from pathlib import Path
from textwrap import dedent

import typer
from rich import print

astgen_cli = typer.Typer()
CURRENT_DIR = Path()

IMPORT_BLOCK = dedent(
    """\
    # THIS FILE HAS BEEN AUTOGENERATED
    import typing as t

    import attr"""
)

# Top level keys are classes that will subclass Expr
# Values are a dictionary of attribute, attribute type (as str) k,v pairs
EXPR_STRUCT = {
    "Binary": {"expr_left": "t.Any", "token_operator": "t.Any", "expr_right": "t.Any"},
    "Grouping": {"expr_expression": "t.Any"},
    "Literal": {"object_value": "t.Any"},
    "Unary": {"token_operator": "t.Any", "expr_right": "t.Any"},
}

INDENT = "    "


def _gen_classdef(
    class_name: str,
    inherits_from: t.Optional[str] = None,
    class_attributes: t.Optional[dict[str, str]] = None,
    slotted: bool = True,
) -> str:
    """
    Generate a class definition from the provided components.

    So we can support the visitor pattern, classes are given an `accept` method that calls a
    class-specific visitor method.

    NOTE: Multiple inheritance is not supported.
    NOTE: Class attributes must have a type specified (as str); empty strings will result in invalid
    syntax in the generated code.
    """
    print(f"{INDENT}Generating {class_name} class ...")
    components = [
        f"@attr.s(slots={slotted})",
    ]

    if inherits_from:
        components.append(f"class {class_name}({inherits_from}):")
    else:
        components.append(f"class {class_name}:")

    if class_attributes:
        components.extend(
            [
                f"{INDENT}{attribute}: {attribute_type} = attr.ib()"
                for attribute, attribute_type in class_attributes.items()
            ]
        )
    else:
        components.append(f"{INDENT}pass")

    components.append("")
    if inherits_from:
        components.append(
            (
                f"{INDENT}def accept(self, visitor: t.Any) -> t.Any:\n"
                f"{INDENT*2}return visitor.visit_{class_name}(self)"
            )
        )
    else:
        # Have base classes raise
        components.append(
            (
                f"{INDENT}def accept(self, visitor: t.Any) -> None:\n"
                f"{INDENT*2}raise NotImplementedError"
            )
        )

    return "\n".join(components)


def define_ast(output_dir: Path, base_name: str, types: dict[str, dict[str, str]]) -> None:
    """
    Generate a module of syntax tree classes & output to the specified directory.

    `types` is a dictionary with class name, class attribute(s) k,v pairs. Class attributes must be
    specified as a dictionary of attribute, attribute type (as str) k,v pairs.

    A base class with `base_name` will be generated in the file, followed by classes built from the
    `types` dictionary. Classes generated from the `types` dictionary will all subclass the base
    class.
    """
    out_filename = output_dir / f"{base_name.lower()}.py"
    print(f"Generating '{base_name.lower()}.py' ...")

    base_classdef = _gen_classdef(base_name)
    out_src = [IMPORT_BLOCK, base_classdef]
    for child, attributes in types.items():
        out_src.append(_gen_classdef(child, base_name, attributes))

    # Build in 2 steps so we can add a newline to the end
    src = "\n\n\n".join(out_src)
    out_filename.write_text(f"{src}\n")


@astgen_cli.command()
def main(output_dir: Path = typer.Argument(default=CURRENT_DIR)) -> None:
    """Automatically generate the syntax tree classes & output to the specified directory."""
    print(f"Autogenerating AST module(s) into '{output_dir}' ...")
    define_ast(output_dir, "Expr", EXPR_STRUCT)


if __name__ == "__main__":
    astgen_cli()
