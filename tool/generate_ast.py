import typing as t
from pathlib import Path
from textwrap import dedent

import typer
from rich import print

astgen_cli = typer.Typer()
CURRENT_DIR = Path()
INDENT = "    "

GRAMMAR_IMPORT_BLOCK = dedent(
    """\
    # THIS FILE HAS BEEN AUTOGENERATED
    from __future__ import annotations

    import typing as t
    from abc import ABC, abstractmethod

    import attr

    from pylox.protocols.visitor import VisitorProtocol
    from pylox.tokens import LITERAL_T, Token"""
)

PROTOCOL_IMPORT_BLOCK = dedent(
    """\
    # THIS FILE HAS BEEN AUTOGENERATED
    from __future__ import annotations

    import typing as t

    from pylox import grammar"""
)

VISIT_PATTERN = (
    "{indent}def visit_{class_name}(self, expr: grammar.{class_name}) -> t.Any:\n"
    "{indent}{indent}...\n"
)

# Top level keys are classes that will subclass Expr
# Values are a dictionary of attribute, attribute type (as str) k,v pairs
SUBCLASS_T = dict[str, dict[str, str]]
EXPR_STRUCT = {
    "Assign": {"name": "Token", "value": "Expr"},
    "Binary": {"expr_left": "Expr", "token_operator": "Token", "expr_right": "Expr"},
    "Call": {"callee": "Expr", "closing_paren": "Token", "arguments": "list[Expr]"},
    "Get": {"object_": "Expr", "name": "Token"},
    "Grouping": {"expr_expression": "Expr"},
    "Literal": {"object_value": "LITERAL_T"},
    "Logical": {"expr_left": "Expr", "token_operator": "Token", "expr_right": "Expr"},
    "Set": {"object_": "Expr", "name": "Token", "value": "Expr"},
    "Super": {"keyword": "Token", "method": "Token"},
    "This": {"keyword": "Token"},
    "Unary": {"token_operator": "Token", "expr_right": "Expr"},
    "Variable": {"name": "Token"},
}

STMT_STRUCT = {
    "Block": {"statements": "list[Stmt]"},
    "Class": {"name": "Token", "superclass": "Variable", "methods": "list[Function]"},
    "Expression": {"expr_expression": "Expr"},
    "Function": {"name": "Token", "params": "list[Token]", "body": "list[Stmt]"},
    "If": {"condition": "Expr", "then_branch": "Stmt", "else_branch": "t.Optional[Stmt]"},
    "Var": {"name": "Token", "initializer": "t.Optional[Expr]"},
    "Return": {"keyword": "Token", "value": "Expr"},
    "Print": {"expr_expression": "Expr"},
    "While": {"condition": "Expr", "body": "Stmt"},
    "Break": {"keyword": "Token"},
    "Continue": {"keyword": "Token"},
}


def _gen_classdef(
    class_name: str,
    inherits_from: t.Optional[str] = None,
    class_attributes: t.Optional[dict[str, str]] = None,
    slotted: bool = True,
    eq: bool = False,
) -> str:
    """
    Generate a class definition from the provided components.

    If `inherits_from` is not specified, then the class is assumed to be an ABC.

    So we can support the visitor pattern, classes are given an `accept` method that calls a
    class-specific visitor method.

    NOTE: Multiple inheritance is not supported.
    NOTE: Class attributes must have a type specified (as str); empty strings will result in invalid
    syntax in the generated code.
    """
    print(f"{INDENT}Generating {class_name} class ...")
    components = []

    if inherits_from:
        # fmt: off
        components.append(
            (
                f"@attr.s(slots={slotted}, eq={eq})\n"
                f"class {class_name}({inherits_from}):"
            )
        )
        # fmt: on
    else:
        components.append(f"class {class_name}(ABC):  # pragma: no cover")

    if class_attributes:
        components.extend(
            [
                f"{INDENT}{attribute}: {attribute_type} = attr.ib()"
                for attribute, attribute_type in class_attributes.items()
            ]
        )
    else:
        components.append(f"{INDENT}pass")

    components.append("")
    if inherits_from:
        components.append(
            (
                f"{INDENT}def accept(self, visitor: VisitorProtocol) -> t.Any:\n"
                f"{INDENT*2}return visitor.visit_{class_name}(self)"
            )
        )
    else:
        # Have base classes raise
        components.append(
            (
                f"{INDENT}@abstractmethod\n"
                f"{INDENT}def accept(self, visitor: VisitorProtocol) -> t.Any:\n"
                f"{INDENT*2}return NotImplemented"
            )
        )

    return "\n".join(components)


def define_ast(output_dir: Path, grammar_defs: dict[str, SUBCLASS_T]) -> None:
    """
    Generate a grammar module of syntax tree classes & output to the specified directory.

    `grammar_defs` is a dictionary with class name, class attribute(s) k,v pairs. Class attributes
    must be specified as a dictionary of attribute, attribute type (as str) k,v pairs.

    A base class with `base_name` will be generated in the file, followed by classes built from the
    `grammar_defs` dictionary. Classes generated from the `types` dictionary will all subclass the
    base class.
    """
    out_filename = output_dir / "grammar.py"
    print(f"Generating '{out_filename.name}' ...")

    out_src = [GRAMMAR_IMPORT_BLOCK]
    for base_name, types in grammar_defs.items():
        out_src.append(_gen_classdef(base_name))
        for child, attributes in types.items():
            out_src.append(_gen_classdef(child, base_name, attributes))

    # Build in 2 steps so we can add a newline to the end
    src = "\n\n\n".join(out_src)
    out_filename.write_text(f"{src}\n")


def define_protocol(output_dir: Path, grammar_names: list[str]) -> None:
    """Generate a Visitor Pattern `Protocol` for the provided syntax tree."""
    out_filename = output_dir / "visitor.py"
    print(f"Generating '{out_filename.name}' ...")

    out_src = [PROTOCOL_IMPORT_BLOCK]
    protocol_src = ["class VisitorProtocol(t.Protocol):"]
    for name in grammar_names:
        protocol_src.append(VISIT_PATTERN.format(indent=INDENT, class_name=name))

    out_src.append("\n".join(protocol_src))
    out_filename.write_text("\n\n\n".join(out_src))


@astgen_cli.command()
def main(output_dir: Path = typer.Argument(default=CURRENT_DIR)) -> None:
    """Automatically generate the syntax tree classes & output to the specified directory."""
    print(f"Autogenerating AST module(s) into '{output_dir}' ...")
    define_ast(
        output_dir,
        {
            "Expr": EXPR_STRUCT,
            "Stmt": STMT_STRUCT,
        },
    )

    output_dir = output_dir / "protocols"
    print(f"Autogenerating Visitor Pattern Protocol into '{output_dir}' ...")
    define_protocol(
        output_dir,
        [
            *EXPR_STRUCT.keys(),
            *STMT_STRUCT.keys(),
        ],
    )


if __name__ == "__main__":
    astgen_cli()
